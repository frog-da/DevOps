## 2.1

```bash
kubectl get po,sts,svc,pvc
NAME                                        READY   STATUS    RESTARTS      AGE
pod/app-python-585cf68698-58h2t             2/2     Running   0             15s
pod/vault-0                                 1/1     Running   2 (12d ago)   16d
pod/vault-agent-injector-5cd8b87c6c-mbjcf   1/1     Running   2 (12d ago)   16d

NAME                     READY   AGE
statefulset.apps/vault   1/1     16d

NAME                               TYPE           CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
service/app-go                     LoadBalancer   10.105.31.63     <pending>     8080:31821/TCP      23d
service/app-python                 LoadBalancer   10.97.23.120     <pending>     80:32075/TCP        16d
service/kubernetes                 ClusterIP      10.96.0.1        <none>        443/TCP             30d
service/vault                      ClusterIP      10.109.162.236   <none>        8200/TCP,8201/TCP   16d
service/vault-agent-injector-svc   ClusterIP      10.109.78.200    <none>        443/TCP             16d
service/vault-internal             ClusterIP      None             <none>        8200/TCP,8201/TCP   16d
```

```bash
kubectl exec pod/app-python-0 -- wc -l counter.txt
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
22 counter.txt
```

```bash
kubectl exec pod/app-python-1 -- wc -l counter.txt
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
28 counter.txt
```

```bash
kubectl exec pod/app-python-2 -- wc -l counter.txt
Defaulted container "app-python" out of: app-python, vault-agent, vault-agent-init (init)
32 counter.txt
```

## 2.2

In this case, similar pods are independent of one another. Keeping a particular order might be required if there was a separation of duties, such as one pod being assigned to reading data and another to writing.

Launching in parallel is implemented using `podManagementPolicy`.

# Bonus.1

The Go app followed the main steps.

During a deployment, Kubernetes update strategies are the means by which outdated pods are swapped out for new ones. The main methods for updating are:

- RollingUpdate: With this default technique, pod updates are applied by the Deployment in a rolling manner. It makes sure that a specific number of pods are always running by progressively replacing the older versions of pods with the more recent versions. This approach is appropriate for production applications and reduces downtime. The two most important parameters for a RollingUpdate are maxSurge and maxUnavailable, which regulate how many new pods can be formed above the target number of pods and how many pods can be unavailable during the update process, respectively.

- Recreate: This tactic ends every previous pod before launching a new one. Since all pods are destroyed before a new pod is generated, there is a period of downtime. This approach may work well for stateless apps where a small amount of downtime is acceptable or if a fresh start is necessary for the new version to operate as intended.

- Blue/Green Deployment: Though not natively supported by Kubernetes as a distinct strategy, it is implemented using service and label selectors. It involves running two versions of an application (blue and green) simultaneously. Once the new version (green) is tested and ready to go live, the traffic is switched from the old version (blue) to the new one. This approach allows for quick rollbacks and minimal downtime but requires double the resources during the switch-over period.

- Blue/Green Deployment: Service and label selectors are used to deploy this approach, even though Kubernetes does not natively support it as a separate one. It entails simultaneously using the blue and green versions of an application. Traffic is shifted from the previous version (blue) to the new one (green) once it has been tested and is prepared for live deployment. Although there is less downtime and speedy rollbacks with this strategy, it does take twice as many resources during the switch-over period.

- A/B Testing: This approach is comparable to Canary Releases, but it concentrates on testing new features with particular user groups or specifications. Instead of just updating it, it's frequently used for testing, which enables developers to get input on new features from real-time traffic prior to complete deployment.